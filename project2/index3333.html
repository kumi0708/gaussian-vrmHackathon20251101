<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Gaussian-VRM Model Switch (nanoPAD2 + Status)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: monospace; }
    #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      color: #00ffcc;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 100;
      pointer-events: none;
      white-space: pre;
    }
  </style>
</head>
<body>
  <div id="status">‚è≥ Loading sample5.gvrm ...</div>
  <canvas id="canvas"></canvas>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
      "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js",
      "gaussian-splats-3d": "https://naruya.github.io/gs-edit/lib/gaussian-splats-3d.module.js",
      "jszip": "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm",
      "gvrm": "https://naruya.github.io/gs-edit/lib/gaussian-vrm.min.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GVRM } from 'gvrm';

    const status = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0.4, 1.5);

    // === „É¢„Éá„É´‰∏ÄË¶ß ===
    const gvrmFiles = [
      "sample1.gvrm",
      "sample2.gvrm",
      "sample3.gvrm",
      "sample4.gvrm",
      "sample5.gvrm",
      "sample6.gvrm",
      "sample7.gvrm",
      "sample8.gvrm",
      "sample9.gvrm"
    ];
    const idleFBX = "../assets/Idle.fbx";

    let currentGvrm = null;
    let isSwitching = false;

    // ============================================================
    // „Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫Èñ¢Êï∞
    // ============================================================
    function showStatus(text, color = "#00ffcc") {
      status.style.color = color;
      status.textContent = text;
    }

    // ============================================================
    // „É¢„Éá„É´„Çí‰∫ãÂâç„Å´Ë™≠„ÅøËæº„ÇÄÔºàÈùûË°®Á§∫„ÅßÔºâ
    // ============================================================
    async function fullyPreloadModel(index, isInitial = false) {
      const file = gvrmFiles[index];
      showStatus(`‚è≥ Loading ${file} ...`);
      console.log("üîÑ Preloading hidden:", file);

      const tempScene = new THREE.Scene();
      const model = await GVRM.load(`../assets/${file}`, tempScene, camera, renderer);

      // ÂàùÂõû‰ª•Â§ñ„ÅØÈùûË°®Á§∫Ôºà„Éó„É™„É≠„Éº„ÉâÁî®Ôºâ
      if (!isInitial && model.gs?.splatMesh) model.gs.splatMesh.visible = false;

      await model.changeFBX(idleFBX);
      console.log("üéû FBX Loaded:", file);

      model.update(0.016);
      return model;
    }

    // ============================================================
    // „É¢„Éá„É´Âàá„ÇäÊõø„Åà
    // ============================================================
    async function switchModel(index) {
      if (isSwitching) return;
      isSwitching = true;

      const file = gvrmFiles[index];
      showStatus(`üîÑ Loading ${file} ...`);
      console.log("‚ú® Switching to model:", file);

      // Êñ∞„É¢„Éá„É´„Çí„É≠„Éº„ÉâÔºàÈùûÂêåÊúüÔºâ
      const newModel = await fullyPreloadModel(index);

      // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥MixerÁ¢∫Ë™ç
      console.log("Mixer:", newModel.character?.currentMixer,
                  "Action:", newModel.character?.currentAction);

      // ÁèæÂú®„É¢„Éá„É´„ÇíÂâäÈô§
      if (currentGvrm) {
        scene.remove(currentGvrm.character?.currentVrm?.scene);
        scene.remove(currentGvrm.gs?.splatMesh);
        console.log("üóë Removed previous model");
      }

      // Êñ∞„É¢„Éá„É´„Çí„Ç∑„Éº„É≥„Å´ËøΩÂä†
      if (newModel.character?.currentVrm?.scene) {
        newModel.character.currentVrm.scene.visible = true;
        scene.add(newModel.character.currentVrm.scene);
      }
      if (newModel.gs?.splatMesh) {
        newModel.gs.splatMesh.visible = true;
        scene.add(newModel.gs.splatMesh);
      }

      currentGvrm = newModel;
      showStatus(`‚úÖ Loaded ${file}`, "#00ff88");
      isSwitching = false;
    }

    // ============================================================
    // ÂàùÂõû„É¢„Éá„É´ (sample5)
    // ============================================================
    const initialIndex = 4; // sample5.gvrm
    const initialModel = await fullyPreloadModel(initialIndex, true);
    scene.add(initialModel.character?.currentVrm?.scene);
    scene.add(initialModel.gs?.splatMesh);
    currentGvrm = initialModel;
    showStatus("‚úÖ Loaded sample5.gvrm", "#00ff88");

    // ============================================================
    // nanoPAD2 ÂÖ•Âäõ„Åß„É¢„Éá„É´ÂàáÊõø
    // ============================================================
    async function initMIDI() {
      if (!navigator.requestMIDIAccess) {
        showStatus("‚ö†Ô∏è MIDI not supported", "#ff4444");
        return;
      }
      const midiAccess = await navigator.requestMIDIAccess();
      midiAccess.inputs.forEach((input) => {
        console.log("üéõ Connected:", input.name);
        input.onmidimessage = (msg) => {
          const [status, note, value] = msg.data;
          if (status === 144 && value > 0) {
            const index = note % gvrmFiles.length;
            switchModel(index);
          }
        };
      });
    }
    initMIDI();

    // ============================================================
    // ÊèèÁîª„É´„Éº„Éó
    // ============================================================
    const clock = new THREE.Clock();
    renderer.setAnimationLoop(() => {
      const delta = clock.getDelta();

      if (currentGvrm) {
        const mixer = currentGvrm.character?.currentMixer;
        // if (mixer) mixer.update(delta);
        currentGvrm.update(delta);
      }

      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
